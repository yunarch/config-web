import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import { styleText } from 'node:util';
import confirm from '@inquirer/confirm';
import { createBaseProgram, runTask } from './utils';

/**
 * Gets the local and remote swagger files and returns their content.
 *
 * @param options - The local swagger file path and the remote swagger URL.
 * @returns Resolves to the local and remote swagger file content, or rejects if an error occurs.
 */
async function getSwaggerFiles({
  localSwaggerPath,
  remoteSwaggerUrl,
}: {
  localSwaggerPath: string;
  remoteSwaggerUrl: string;
}) {
  const [localSwagger, remoteSwagger] = await Promise.all([
    runTask({
      name: 'Reading local swagger file',
      command: readFile(localSwaggerPath, 'utf8'),
    }),
    runTask({
      name: 'Reading server swagger file',
      command: `curl -s ${remoteSwaggerUrl}`,
    }),
  ]);
  return { localSwagger, remoteSwagger };
}

/**
 * Asks the user if they want to use the remote swagger and generate new API models.
 *
 * @param params - The local swagger file path, the remote swagger content, and the force generation flag.
 * @returns Resolves to true if the user confirms, otherwise false.
 */
async function syncSwaggerFiles({
  remoteSwagger,
  localSwaggerPath,
  forceGenModels,
}: {
  remoteSwagger: string;
  localSwaggerPath: string;
  forceGenModels: boolean;
}) {
  const userConfirmed = await confirm({
    message: forceGenModels
      ? 'Do you want to use the remote swagger? (y/n)?'
      : 'Do you want to use the remote swagger and generate new API models? (y/n)?',
  });
  if (userConfirmed) {
    await runTask({
      name: 'Replacing local swagger.json with remote',
      command: writeFile(localSwaggerPath, remoteSwagger),
    });
    return true;
  }
  return false;
}

/**
 * Generates models and a swagger type definition file based on the provided input and output paths.
 * Optionally runs a post script after the generated files has finished.
 *
 * @param params - The input and output paths and the optional post script.
 * @returns Resolves when all tasks are completed or rejects if an error occurs.
 */
async function generateModels({
  localSwaggerPath,
  modelsFolder,
  postScript,
}: {
  localSwaggerPath: string;
  modelsFolder: string;
  postScript?: string;
}) {
  await runTask({
    name: 'Generating models',
    command: `npx openapi-typescript-codegen --input ${localSwaggerPath} --output ${modelsFolder} --client fetch`,
  });
  await runTask({
    name: 'Generating swagger type definition',
    command: async () => {
      const content = await readFile(localSwaggerPath, 'utf8');
      await writeFile(
        `${modelsFolder}/swagger.d.ts`,
        `/* generated -- do not edit */\n/* eslint-disable -- Autogenerated file */\ndeclare const schema: ${content}; export default schema;`
      );
    },
  });
  if (postScript) {
    await runTask({
      name: 'Running post script',
      command: `node --run ${postScript}`,
    });
  }
}

/**
 * Main function to run the CLI script.
 *
 * @param options - The CLI options.
 */
async function run({
  url: remoteSwaggerUrl,
  output: localSwaggerPath,
  modelsFolder,
  forceGenModels,
  postScript,
}: {
  url: string;
  output: string;
  modelsFolder: string;
  forceGenModels?: boolean;
  postScript?: string;
}) {
  console.log(styleText('magenta', '\nüöÄ Swagger-sync ‚ú®\n'));
  const hasLocalSwaggerPath = existsSync(localSwaggerPath);
  if (!hasLocalSwaggerPath) {
    await runTask({
      name: 'Downloading swagger.json',
      command: `curl ${remoteSwaggerUrl} -o ${localSwaggerPath}`,
    });
  }
  const { localSwagger, remoteSwagger } = await getSwaggerFiles({
    localSwaggerPath,
    remoteSwaggerUrl,
  });
  if (
    !hasLocalSwaggerPath ||
    JSON.stringify(JSON.parse(localSwagger)) !==
      JSON.stringify(JSON.parse(remoteSwagger))
  ) {
    console.log(
      styleText(
        'yellow',
        '\n‚ö†Ô∏è  Local and remote swagger.json does not match!\n'
      )
    );
    const confirmed = await syncSwaggerFiles({
      localSwaggerPath,
      remoteSwagger,
      forceGenModels: !!forceGenModels,
    });
    if (!confirmed) {
      console.log(styleText('yellow', '\n‚ö†Ô∏è  Sync remote swagger skipped.\n'));
      if (!forceGenModels) process.exit(0);
    }
  } else if (!forceGenModels && existsSync(modelsFolder)) {
    console.log(
      styleText(
        'blue',
        '\nLocal and remote swagger are identical. No updates required.\n'
      )
    );
    process.exit(0);
  }
  await generateModels({ localSwaggerPath, modelsFolder, postScript });
  console.log(
    styleText('green', '\n‚úÖ Sync swagger and models generation completed!\n')
  );
}

// Define and run the CLI program
createBaseProgram()
  .name('swagger-sync')
  .description(
    'A CLI tool to synchronize a local swagger file with a remote and generate API models.'
  )
  .requiredOption(
    '--url <url>',
    'The remote swagger file URL to download and compare.'
  )
  .requiredOption('--output <path>', 'The path to save the local swagger file.')
  .requiredOption(
    '--models-folder <path>',
    'The path to save the generated models and swagger type definition.'
  )
  .option(
    '--force-gen-models',
    'Force the generation of models even if the local and remote swagger files are identical.'
  )
  .option(
    '--post-script <script>',
    'A package.json script name to be executed after the generated files has finished. (e.g. to run a formatter)'
  )
  .action(
    async (options: {
      url: string;
      output: string;
      modelsFolder: string;
      forceGenModels?: boolean;
      postScript?: string;
    }) => {
      try {
        await run({
          url: options.url,
          output: options.output,
          modelsFolder: options.modelsFolder,
          forceGenModels: options.forceGenModels,
          postScript: options.postScript,
        });
      } catch (error) {
        console.error(error);
        process.exit(1);
      }
    }
  )
  .parseAsync(process.argv);
